(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{376:function(t,n,e){"use strict";e.r(n);var s=e(7),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("ul",[n("li",[t._v("C++为每个非静态成员函数提供一个this指针")]),t._v(" "),n("li",[t._v("this指针是一个隐含的指针，它指向了正在被成员函数操作的那个对象，且该指针的值不能被改写")]),t._v(" "),n("li",[t._v("this指针不能显式声明，它只是非静态成员函数的一个形参")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Counter{\n  int value;\npublic:\n  void setValue( int value ){\n\t  this->value = value;\n  }\n  ……\n};\n\nvoid main(){\n   Counter obj1,obj2;\n   obj1.setValue(1);//该对象中setValue()内的this指针指向obj\n   obj2.setValue(2);\n}\n")])])]),n("p",[t._v("类内函数可以直接访问类内数据成员的原因是\n![[Pasted image 20230404202811.png]]\n本质上就是通过this指针实现的")])])}),[],!1,null,null,null);n.default=a.exports}}]);